#ifndef _INCLUDE_GUARD_MATRIX4X4F_H_
#define _INCLUDE_GUARD_MATRIX4X4F_H_



//==================================================================================================================================
// マクロ定義
//==================================================================================================================================

// 単位行列
#define MATRIX4X4F_IDENTITY		Matrix4x4F( 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1 )

// 零行列
#define MATRIX4X4F_ZERO			Matrix4x4F( 0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0 )



//==================================================================================================================================
// インクルード
//==================================================================================================================================

#ifndef _INCLUDE_GUARD_VECTOR4DF_H_
#include "../Vector/Vector4DF.h"
#endif	// #ifndef _INCLUDE_GUARD_VECTOR4DF_H_



//==================================================================================================================================
// クラス定義
//==================================================================================================================================

//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 4行4列マトリクスクラス
//
// @note : 
//
// 4行4列の行列を表現したクラス。
// 16の浮動小数値を管理し、4×4行列として扱えるようにする。
//----------------------------------------------------------------------------------------------------------------------------------
class Matrix4x4F 
{
public:

	// コンストラクタ
	Matrix4x4F();
	
	// コンストラクタ
	Matrix4x4F( 
		const float fM11, const float fM12, const float fM13, const float fM14,
		const float fM21, const float fM22, const float fM23, const float fM24,
		const float fM31, const float fM32, const float fM33, const float fM34,
		const float fM41, const float fM42, const float fM43, const float fM44 
	);
	
	// コンストラクタ
	Matrix4x4F( const float ( &fMatrix )[16] );



	// 単位行列化
	void Identity();

	// 行列の転置
	void Transpose();


	void ConsoleOutPut() const;


	
	// 添字演算子オーバーロード
	float* operator [] ( const unsigned int uiIndex );

	// 単項プラス演算子オーバーロード
	Matrix4x4F operator + () const;

	// 単項マイナス演算子オーバーロード
	Matrix4x4F operator - () const;
	
	// 加算演算子オーバーロード
	Matrix4x4F operator + ( const Matrix4x4F& mat4 ) const;
	
	// 減算演算子オーバーロード
	Matrix4x4F operator - ( const Matrix4x4F& mat4 ) const;
	
	// 乗算演算子オーバーロード( 行列×定数 )
	Matrix4x4F operator * ( const float fK ) const;

	// 乗算演算子オーバーロード( 行列×行列 )
	Matrix4x4F operator * ( const Matrix4x4F& mat4 ) const;

	// 乗算演算子オーバーロード( 行列×ベクトル )
	Vector4DF operator * ( Vector4DF& vec4 ) const;
	
	// 除算演算子オーバーロード( 行列÷定数 )
	Matrix4x4F operator / ( const float fK ) const;

	// 代入演算子オーバーロード
	const Matrix4x4F& operator = ( const Matrix4x4F& mat4 );

	// 代入演算子オーバーロード
	const Matrix4x4F& operator = ( const float ( &fMatrix )[16] );

	// 加算代入演算子オーバーロード
	const Matrix4x4F& operator += ( const Matrix4x4F& mat4 );

	// 減算代入演算子オーバーロード
	const Matrix4x4F& operator -= ( const Matrix4x4F& mat4 );

	// 乗算代入演算子オーバーロード( 行列×定数 )
	const Matrix4x4F& operator *= ( const float fK );

	// 除算代入演算子オーバーロード( 行列÷定数 )
	const Matrix4x4F& operator /= ( const float fK );

public:

	// メンバ変数

	union
	{
		float		m[4][4];
		struct
		{
			float	_11, _12, _13, _14;
			float	_21, _22, _23, _24;
			float	_31, _32, _33, _34;
			float	_41, _42, _43, _44;
		};
		float		v[16];
	};
};



//==================================================================================================================================
// 関数定義
//==================================================================================================================================

//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : コンストラクタ
//
// @note : 
//
//----------------------------------------------------------------------------------------------------------------------------------
inline Matrix4x4F::Matrix4x4F()
{
	*this = MATRIX4X4F_ZERO;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : コンストラクタ
//
// @param [in] / const float fM11 : 1行目1列目の成分
// @param [in] / const float fM12 : 1行目2列目の成分
// @param [in] / const float fM13 : 1行目3列目の成分
// @param [in] / const float fM14 : 1行目4列目の成分
// @param [in] / const float fM21 : 2行目1列目の成分
// @param [in] / const float fM22 : 2行目2列目の成分
// @param [in] / const float fM23 : 2行目3列目の成分
// @param [in] / const float fM24 : 2行目4列目の成分
// @param [in] / const float fM31 : 3行目1列目の成分
// @param [in] / const float fM32 : 3行目2列目の成分
// @param [in] / const float fM33 : 3行目3列目の成分
// @param [in] / const float fM34 : 3行目4列目の成分
// @param [in] / const float fM41 : 4行目1列目の成分
// @param [in] / const float fM42 : 4行目2列目の成分
// @param [in] / const float fM43 : 4行目3列目の成分
// @param [in] / const float fM44 : 4行目4列目の成分
//
// @note : 
//
//----------------------------------------------------------------------------------------------------------------------------------
inline Matrix4x4F::Matrix4x4F( 
	const float fM11, const float fM12, const float fM13, const float fM14,
	const float fM21, const float fM22, const float fM23, const float fM24,
	const float fM31, const float fM32, const float fM33, const float fM34,
	const float fM41, const float fM42, const float fM43, const float fM44
) : 
	_11( fM11 ), _12( fM12 ), _13( fM13 ), _14( fM14 ),
	_21( fM21 ), _22( fM22 ), _23( fM23 ), _24( fM24 ),
	_31( fM31 ), _32( fM32 ), _33( fM33 ), _34( fM34 ),
	_41( fM41 ), _42( fM42 ), _43( fM43 ), _44( fM44 )
{
	
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : コンストラクタ
//
// @param [in] / const float ( &fMatrix )[16] : 4×4行列の1次元配列
//
// @note : 
//
//----------------------------------------------------------------------------------------------------------------------------------
inline Matrix4x4F::Matrix4x4F( const float ( &fMatrix )[16] ) : 
	_11( fMatrix[0] ), _12( fMatrix[1] ), _13( fMatrix[2] ), _14( fMatrix[3] ),
	_21( fMatrix[4] ), _22( fMatrix[5] ), _23( fMatrix[6] ), _24( fMatrix[7] ),
	_31( fMatrix[8] ), _32( fMatrix[9] ), _33( fMatrix[10] ), _34( fMatrix[11] ),
	_41( fMatrix[12] ), _42( fMatrix[13] ), _43( fMatrix[14] ), _44( fMatrix[15] )
{
	
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 単位行列化
//
// @note : 
//
// 行列を単位行列にする。
//----------------------------------------------------------------------------------------------------------------------------------
inline void Matrix4x4F::Identity() 
{
	*this = MATRIX4X4F_IDENTITY;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 行列の転置
//
// @note : 
//
// 行列を転置する。
//----------------------------------------------------------------------------------------------------------------------------------
inline void Matrix4x4F::Transpose() 
{
	int iOffset = 0;

	for ( int i = 0; i < 4 - 1; i++ ) 
	{
		for ( int j = 1 + iOffset; j < 4; j++ ) 
		{
			float fTmp	= m[i][j];
			m[i][j]		= m[j][i];
			m[j][i]		= fTmp;
		}

		iOffset++;
	} 
}



#ifndef _INCLUDE_GUARD_IOSTREAM_H_
#define _INCLUDE_GUARD_IOSTREAM_H_
#include <iostream>
#endif	// #ifndef _INCLUDE_GUARD_IOSTREAM_H_
inline void Matrix4x4F::ConsoleOutPut() const 
{
/*
	for ( int i = 0; i < 16; i++ ) 
	{
		printf( "%f", v[i] );

		if ( ( ( i + 1 ) % 4 ) != 0 ) 
		{ 
			printf( " " ); 
		}
		
		else 
		{
			printf( "\n" );
		}
	}
*/
	for ( int i = 0; i < 4; i++ ) 
	{
		printf( "%f %f %f %f\n", m[i][0], m[i][1], m[i][2], m[i][3] );
	}
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 添字演算子オーバーロード
//
// @param [in] / const unsigned int uiIndex : 行列の要素を格納する二次元配列の行インデックス
//
// @return / float* :  行列の要素を格納する二次元配列の列の配列
//
// @note : 
//
// 4行4列マトリクスクラスの添え字を定義する。
//----------------------------------------------------------------------------------------------------------------------------------
inline float* Matrix4x4F::operator [] ( const unsigned int uiIndex )
{
	return m[ ( uiIndex < 4 ) ? uiIndex : 4 - 1 ];
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 単項プラス演算子オーバーロード
//
// @return / Matrix4x4F : 自身の行列
//
// @note : 
//
// 自身の行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline Matrix4x4F Matrix4x4F::operator + () const
{
	return *this;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 単項マイナス演算子オーバーロード
//
// @return / Matrix4x4F : 行列の各成分の符号を反転した行列
//
// @note : 
//
// 行列の各成分の符号を反転した行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline Matrix4x4F Matrix4x4F::operator - () const
{
	Matrix4x4F mat4Ret;

	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			mat4Ret[i][j] = -m[i][j];
		}
	}



	return mat4Ret;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 加算演算子オーバーロード
//
// @param [in] / const Matrix4x4F& mat4 : 4行4列マトリクスクラスのインスタンス
//
// @return / Matrix4x4F : 行列の各成分を加算した行列
//
// @note : 
//
// 4行4列マトリクスクラス同士の加算演算を定義する。
// 行列の各成分を加算した行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline Matrix4x4F Matrix4x4F::operator + ( const Matrix4x4F& mat4 ) const
{
	Matrix4x4F mat4Ret;

	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			mat4Ret[i][j] = m[i][j] + mat4.m[i][j];
		}
	}



	return mat4Ret;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 減算演算子オーバーロード
//
// @param [in] / const Matrix4x4F& mat4 : 4行4列マトリクスクラスのインスタンス
//
// @return / Matrix4x4F : 行列の各成分を減算した行列
//
// @note : 
//
// 4行4列マトリクスクラス同士の減算演算を定義する。
// 行列の各成分を減算した行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline Matrix4x4F Matrix4x4F::operator - ( const Matrix4x4F& mat4 ) const
{
	Matrix4x4F mat4Ret;

	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			mat4Ret[i][j] = m[i][j] - mat4.m[i][j];
		}
	}



	return mat4Ret;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 乗算演算子オーバーロード( 行列×定数 )
//
// @param [in] / const float fK : 行列に乗算する定数
//
// @return / Matrix4x4F : 行列の各成分を乗算した行列
//
// @note : 
//
// 4行4列マトリクスクラスと定数の乗算演算を定義する。
// 行列の各成分を乗算した行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline Matrix4x4F Matrix4x4F::operator * ( const float fK ) const
{
	Matrix4x4F mat4Ret;

	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			mat4Ret[i][j] = m[i][j] * fK;
		}
	}



	return mat4Ret;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 乗算演算子オーバーロード( 行列×行列 )
//
// @param [in] / const Matrix4x4F& mat4 : 行列に乗算する行列
//
// @return / Matrix4x4F : 行列の各成分を乗算した行列
//
// @note : 
//
// 4行4列マトリクスクラス同士の乗算演算を定義する。
// 行列の各成分を乗算した行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline Matrix4x4F Matrix4x4F::operator * ( const Matrix4x4F& mat4 ) const
{
	Matrix4x4F mat4Ret;

	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			mat4Ret[i][j] = 
				m[i][0] * mat4.m[0][j] +
				m[i][1] * mat4.m[1][j] +
				m[i][2] * mat4.m[2][j] +
				m[i][3] * mat4.m[3][j];
		}
	}



	return mat4Ret;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 乗算演算子オーバーロード( 行列×ベクトル )
//
// @param [in] / Vector4DF& vec4 : 行列に乗算するベクトル
//
// @return / Vector4DF : 行列を乗算したベクトル
//
// @note : 
//
// 4行4列マトリクスクラスと4次元ベクトルクラスの乗算演算を定義する。
//----------------------------------------------------------------------------------------------------------------------------------
inline Vector4DF Matrix4x4F::operator * ( Vector4DF& vec4 ) const
{
	Vector4DF vec4Ret;

	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			vec4Ret[i] += m[i][j] * vec4[j];
		}
	}



	return vec4Ret;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 除算演算子オーバーロード( 行列÷定数 )
//
// @param [in] / const float fK : 行列に除算する定数
//
// @return / Matrix4x4F : 行列の各成分を除算した行列
//
// @note : 
//
// 4行4列マトリクスクラスと定数の除算演算を定義する。
// 行列の各成分を除算した行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline Matrix4x4F Matrix4x4F::operator / ( const float fK ) const
{
	Matrix4x4F mat4Ret;

	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			mat4Ret[i][j] = m[i][j] / fK;
		}
	}



	return mat4Ret;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 代入演算子オーバーロード
//
// @param [in] / const Matrix4x4F& mat4 : 4行4列マトリクスクラスのインスタンス
//
// @return / const Matrix4x4F& : 行列の各成分を代入した自身の行列
//
// @note : 
//
// 4行4列マトリクスクラス同士の代入演算を定義する。
// 行列の各成分を自身の行列の各成分に代入した自身の行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline const Matrix4x4F& Matrix4x4F::operator = ( const Matrix4x4F& mat4 ) 
{
	for ( int i = 0; i < 16; i++ ) 
	{
		v[i] = mat4.v[i];
	}



	return *this;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 代入演算子オーバーロード
//
// @param [in] / const float ( &fMatrix )[16] : 4×4行列の1次元配列
//
// @return / const Matrix4x4F& : 行列の各成分を代入した自身の行列
//
// @note : 
//
// 4行4列マトリクスクラスと4×4行列の1次元配列の代入演算を定義する。
// 行列の各成分を自身の行列の各成分に代入した自身の行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline const Matrix4x4F& Matrix4x4F::operator = ( const float ( &fMatrix )[16] ) 
{
	for ( int i = 0; i < 16; i++ ) 
	{
		v[i] = fMatrix[i];
	}



	return *this;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 加算代入演算子オーバーロード
//
// @param [in] / const Matrix4x4F& mat4 : 4行4列マトリクスクラスのインスタンス
//
// @return / const Matrix4x4F& : 行列の各成分の加算結果を代入した自身の行列
//
// @note : 
//
// 4行4列マトリクスクラス同士の加算代入演算を定義する。
// 行列の各成分と自身の行列の各成分の加算結果を代入した自身の行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline const Matrix4x4F& Matrix4x4F::operator += ( const Matrix4x4F& mat4 )
{
	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			m[i][j] += mat4.m[i][j];
		}
	}



	return *this;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 減算代入演算子オーバーロード
//
// @param [in] / const Matrix4x4F& mat4 : 4行4列マトリクスクラスのインスタンス
//
// @return / const Matrix4x4F& : 行列の各成分の減算結果を代入した自身の行列
//
// @note : 
//
// 4行4列マトリクスクラス同士の減算代入演算を定義する。
// 行列の各成分と自身の行列の各成分の減算結果を代入した自身の行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline const Matrix4x4F& Matrix4x4F::operator -= ( const Matrix4x4F& mat4 )
{
	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			m[i][j] -= mat4.m[i][j];
		}
	}



	return *this;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 乗算代入演算子オーバーロード( 行列×定数 )
//
// @param [in] / const float fK : 行列に乗算する定数
//
// @return / const Matrix4x4F& : 行列の各成分の乗算結果を代入した自身の行列
//
// @note : 
//
// 4行4列マトリクスクラスと定数の乗算代入演算を定義する。
// 行列の各成分と定数の乗算結果を代入した自身の行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline const Matrix4x4F& Matrix4x4F::operator *= ( const float fK )
{
	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			m[i][j] *= fK;
		}
	}



	return *this;
}



//----------------------------------------------------------------------------------------------------------------------------------
// @purpose : 除算代入演算子オーバーロード( 行列÷定数 )
//
// @param [in] / const float fK : 行列に除算する定数
//
// @return / const Matrix4x4F& : 行列の各成分の除算結果を代入した自身の行列
//
// @note : 
//
// 4行4列マトリクスクラスと定数の除算代入演算を定義する。
// 行列の各成分と定数の除算結果を代入した自身の行列を返す。
//----------------------------------------------------------------------------------------------------------------------------------
inline const Matrix4x4F& Matrix4x4F::operator /= ( const float fK )
{
	for ( int i = 0; i < 4; i++ ) 
	{
		for ( int j = 0; j < 4; j++ ) 
		{
			m[i][j] /= fK;
		}
	}



	return *this;
}



#endif	// #ifndef _INCLUDE_GUARD_MATRIX4X4F_H_